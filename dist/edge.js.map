{"version":3,"sources":["edge.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"edge.js","sourcesContent":["// all you have to do in the out extension is case detect to traverse\n// to inout or outin based on where you came in from\n// (probably by checking the UUID/soul of the out node and making\n// sure it is !== to where you just came from)\n// and of course having another wrapper method around\n// setting/adding edges would be nice too, maybe like gun.edge(data)\n// to complement gun.out(property)\n\n// oh, and of course don't forget to mark.spouse = edge; amber.spouse = edge\n// (oh, and stupid comment, make sure to make edge have a edge.type = \"edge\"\n// so you can type check against it internally and know it is an edge \"node\" not a\n// regular node)\n// (this is the primary reason edges aren't built into gun, cause there\n// is nothing inherently \"special\" about them to warrant the entire database\n// always having the overhead of an extra edge it has to jump through\n// [slows down performance just slightly] unless it is explicitly needed/wanted)\n\n// travels an edge to another node\n// tests that the property is an edge\n\n// gun.get('amber').get('spouse').get('outin').val(cb)\n\n// shorthand\n// gun.get('amber').out('spouse')\n\n// export const edge = (property, edge) => {\n//   const gun = this\n\n//   const name = edge.name\n//   const from = edge.from\n//   const to = edge.outin\n//   console.log('add edge', edge, 'from', from, 'to', to)\n\n//   from.put({\n//     [name]: edge\n//   })\n\n//   to.put({\n//     [name]: edge\n//   })\n// }"]}